package main

import (
	"bytes"
	"compress/gzip"
	"crypto/md5"
	"encoding/hex"
	"flag"
	"fmt"
	"go/format"
	"io"
	"mime"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

var pkgName = flag.String("package", "static", "Package name")
var staticPath = flag.String("path", "./html", "Directory with static files")
var outFile = flag.String("out", "static.go", "Output file name")

func main() {
	flag.Parse()

	absStaticPath, err := filepath.Abs(*staticPath)
	if err != nil {
		fmt.Print(err)
		os.Exit(1)
	}

	outFileInfo, err := os.Stat(*outFile)
	if err == nil {
		maxUpdateTime := time.Time{}
		if err := filepath.Walk(absStaticPath, func(path string, f os.FileInfo, err error) error {
			if f.ModTime().After(maxUpdateTime) {
				maxUpdateTime = f.ModTime()
			}
			return nil
		}); err != nil {
			fmt.Print(err)
			os.Exit(1)
		}

		if outFileInfo.ModTime().After(maxUpdateTime) {
			os.Exit(0)
		}
	}

	content := &bytes.Buffer{}
	if err := filepath.Walk(absStaticPath, func(path string, f os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if f == nil || f.IsDir() {
			return nil
		}

		fileName := strings.TrimPrefix(path, absStaticPath)

		buf := &bytes.Buffer{}
		goBytes := NewGoByteWriter(buf)
		gz, _ := gzip.NewWriterLevel(goBytes, gzip.BestCompression)

		file, err := os.Open(path)
		if err != nil {
			return err
		}

		_, err = io.Copy(gz, file)

		file.Close()
		gz.Close()

		if err != nil {
			return err
		}

		content.WriteString("\"")
		content.WriteString(fileName)
		content.WriteString("\": {\n")
		content.WriteString("ContentType: `" + mime.TypeByExtension(fileName[strings.LastIndex(fileName, "."):]) + "`,\n")
		hs := md5.Sum(buf.Bytes())
		content.WriteString("ETag: \"" + hex.EncodeToString(hs[:8]) + "\",\n")
		content.WriteString("Data: []byte{")
		content.Write(buf.Bytes())
		content.WriteString("\n},\n},\n")

		return nil
	}); err != nil {
		fmt.Print(err)
		os.Exit(1)
	}

	result := regexp.MustCompilePOSIX(">>>PKG_NAME<<<").ReplaceAll(template, []byte(*pkgName))
	result = regexp.MustCompilePOSIX(">>>FILES<<<").ReplaceAll(result, content.Bytes())

	result, err = format.Source(result)
	if err != nil {
		println(content.String())
		fmt.Print(err)
		os.Exit(1)
	}

	if err := os.MkdirAll(filepath.Dir(*outFile), 0777); err != nil {
		fmt.Print(err)
		os.Exit(1)
	}

	of, err := os.Create(*outFile)
	defer of.Close()
	if err != nil {
		fmt.Print(err)
		os.Exit(1)
	}

	of.Write(result)
}

var template = []byte(`// It's autogenerated file. Do not modify it.
// Generated by https://github.com/sergei-svistunov/gostatic2lib

package >>>PKG_NAME<<<

import (
	"net/http"
	"strings"
)

type HTTPHandler struct {
	files map[string]File
}

type File struct {
	ContentType string
	ETag string
	Data []byte
}

func NewHTTPHandler() *HTTPHandler {
	return &HTTPHandler{
		files: map[string]File{
			>>>FILES<<<
		},
	}
}

func (h *HTTPHandler) GetFile(fileName string) *File {
	File, exists := h.files[fileName]
	if !exists || strings.LastIndex(fileName, ".") < 1 {
		return nil
	}

	return &File
}

func (h *HTTPHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fileName := r.URL.Path
	if fileName == "/" {
		fileName = "/index.html"
	}

	file := h.GetFile(fileName)
	if file == nil {
		http.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)
		return
	}

	if r.Header.Get("If-None-Match") == file.ETag {
		http.Error(w, http.StatusText(http.StatusNotModified), http.StatusNotModified)
		return
	}

	w.Header().Set("Content-Type", file.ContentType)
	w.Header().Set("Content-Encoding", "gzip")
	w.Header().Set("ETag", file.ETag)

	_, _ = w.Write(file.Data)
}
`)
